[
  {
    "ID": 12,
    "title": "常见网络面试题",
    "detail": "目录 常考面试题 1. Post 和 Get 的区别？ 2. TLS/SSL中什么一定要用三个随机数，来生成会话密钥？ 3. SSL 连接断开后如何恢复？ 4.RSA 算法的安全性保障？ 5. DNS 为什么使用 UDP 协议作为传输层协议？ 6.当你在浏览器中输",
    "img": "network.jpg",
    "link": "https://www.cnblogs.com/pengnima/p/12660295.html",
    "tags": ["面试题", "网络"],
    "date": "1586331420000"
  },
  {
    "ID": 11,
    "title": "传输层",
    "detail": "传输层协议主要是为不同主机上的不同进程间提供了逻辑通信的功能。传输层只工作在端对端系统中。 传输层需要 2 种不同传输协议： 面向连接 TCP 和 非连接 UDP 主要协议有：TCP 和 UDP 。 实现的主要功能：保证传输的可靠性，并且实现一些差错恢复机制。 传输层的端口：实际上是用来标识",
    "img": "transmission.jpg",
    "link": "https://www.cnblogs.com/pengnima/p/12660278.html",
    "tags": ["TCP", "UDP", "三次握手", "四次挥手"],
    "date": "1586331420000"
  },
  {
    "ID": 10,
    "title": "应用层",
    "detail": "应用层协议定义了应用进程间的交互和通信规则，不同主机的应用进程间如何相互传递报文，比如传递的报文的类型、格式、有哪些字段等等。 目录 HTTP 协议 概况 报文 状态码 HTTP2 HTTPS DNS HTTP 协议 概况 HTTP 是超文本传输协议，定义了客户端",
    "img": "app.jpg",
    "link": "https://www.cnblogs.com/pengnima/p/12660295.html",
    "tags": ["HTTP", "HTTPS", "网络协议", "DNS"],
    "date": "1586331420000"
  },
  {
    "ID": 9,
    "title": "WAA可视化",
    "detail": "AnalyserNode 数据分析和可视化，如果你想从音频里提取时间、频率或者其它数据，你需要 AnalyserNode。 AnalyserNode 表示一个可以提供实时频率分析与时域分析的切点，这些分析数据可以用做数据分析和可视化。 创建 AudioContext 的 createAnalyser ",
    "img": "audio_disk.jpg",
    "link": "https://www.cnblogs.com/pengnima/p/12660295.html",
    "tags": ["可视化", "WAA分析器"],
    "date": "1586006400000"
  },
  {
    "ID": 8,
    "title": "FileReader",
    "detail": "FileReader 文档地址 FileReader (文件读取器) FileReader 对象允许 Web 应用程序异步读取存储在用户计算机上的文件（或原始数据缓冲区）的内容 File 对象可以是来自用户在一个 input 元素上选择文件后返回的 FileList 对象,也可以来自拖放操作生成",
    "img": "reader.jpg",
    "link": "",
    "tags": ["文件阅读", "文件读取"],
    "date": "1586006400000"
  },
  {
    "ID": 7,
    "title": "WebAudioAPI",
    "detail": "Web Audio API 提供了在 Web 上控制音频的一个非常有效通用的系统，允许开发者来自选音频源，对音频添加特效，使音频可视化，添加空间效果 （如平移），等等。 AudioContext 接口表示由音频模块连接而成的音频处理图，每个模块对应一个 AudioNode。 AudioContext",
    "img": "audio_room.jpg",
    "link": "",
    "tags": ["API", "音乐", "可视化"],
    "date": "1586006400000"
  },
  {
    "ID": 6,
    "title": "基数排序",
    "detail": "不需要比较，基于 分配 + 收集 的思想。 思路： 桶实际上是队列，先进先出 1. 建 10 个 桶，分别为 0~9 2. 第一趟分配(按 个位 排),把数丢到 桶里 3. 然后 收集回来(回来之后会发现 数的个位为有序的了) 4. 第二趟分配(按 十位 排) 5. 然后 收集回来(回来之",
    "img": "tong_sort.jpg",
    "link": "",
    "tags": ["排序", "算法", "桶排"],
    "date": "1586006400000"
  },
  {
    "ID": 5,
    "title": "归并排序",
    "detail": "1. 把 2 个及以上的有序子序列，归并 成一个有序序列 2. 内部排序中，多采用 二路 归并排序 3. 整个归并排序只需要 logN 躺 基本思想： 1. 切分步骤：先将大数组，拆分成 2 组，然后 2 组再拆分，直到元素个数为 1， 2. 合并步骤：接着两个 单一元素比较合并，合并",
    "img": "merge_sort.jpg",
    "link": "",
    "tags": ["排序", "算法", "二路归并"],
    "date": "1585897020000"
  },
  {
    "ID": 4,
    "title": "选择排序",
    "detail": "1. 简单选择排序_ 时间复杂度 O(n^2) 思路： 从头到尾扫描数列，找出最小的，和第一个交换，然后剩余的重复如此 js let len = list.length; //创建堆 function CreatHeap(list) { let i; for (i = Math.floo",
    "img": "select_sort.jpg",
    "link": "",
    "tags": ["排序", "算法", "堆排", "简单选择"],
    "date": "1585897020000"
  },
  {
    "ID": 3,
    "title": "交换排序",
    "detail": "通过比较关键字，然后交换 _1. 冒泡排序_ 时间复杂度 O(n^2) 思路： 1. 两两比较，大的那个放在最右边，比较到最末尾之后，最右边 即 最大 2. 第二轮的比较中，将最大的排开，即 len = 1，后面几轮也同样如此 3. 最大的那个就会像冒泡一样，一个一个像最右靠 _2. 快速",
    "img": "bubble_sort.jpg",
    "link": "",
    "tags": ["排序", "算法", "冒泡", "快排"],
    "date": "1585897020000"
  },
  {
    "ID": 2,
    "title": "插入排序",
    "detail": "在一个有序的数据序列中，插入一个数，且插入后一样有序，时间复杂度 O(n^2)，适用于少量数据的排序 _1. 直接插入排序_ 时间复杂度 O(n^2) 思路： 类似抓扑克牌 3 2 7 4 1 = 2 3 7 4 1 = 2 3 4 7 1 = 1 2 3 4 7 把前面的数当成是有序的",
    "img": "insert_sort.jpg",
    "link": "",
    "tags": ["排序", "算法", "希尔", "直接插入", "二分法"],
    "date": "1585897020000"
  },
  {
    "ID": 1,
    "title": "排序算法简介",
    "detail": "1. 排序成有序的顺序表则可以采用查找效率较高的二分法(折半查找法)，而无序只能进行顺序查找 2. 排序两大类： 内部排序：待排序内容不大可以存放再计算机内存中进行排序 外部排序：带排序内容很大，需要借助外存进行排序，一般会用归并排序，因为归并不需要一次性把所有数据都存入内存 3. 内部排序",
    "img": "sort_algorithm.jpg",
    "link": "",
    "tags": ["排序", "算法"],
    "date": "1585897020000"
  }
]
